#!/bin/bash

# Optimized pacheck - Fast parallel package checker for Arch Linux
# Made by zeroz/tj - Optimized version with fast AUR batch checking

# Dependencies: expac, curl, jq
# Optional: pacman-contrib (for paccache)

# Set safer bash options
set -o pipefail

# Terminal colors
readonly COL_RESET="\e[0m"
readonly COL_BOLD="\e[1m"
readonly COL_RED="\e[31m"
readonly COL_GREEN="\e[32m"
readonly COL_YELLOW="\e[33m"
readonly COL_BLUE="\e[34m"
readonly COL_CYAN="\e[36m"
readonly COL_MAGENTA="\e[35m"
readonly COL_DIM="\e[2m"
readonly COL_HIGHLIGHT="\e[94m"

# Unicode symbols
readonly CHECK_MARK=$'\u2714'
readonly X_MARK=$'\u2718'
readonly UP_ARROW=$'\u2191'
readonly WARNING=$'\u25B2'
readonly DIVIDER="────────────────────────────────────"

# Global settings
declare -g search_desc=false
declare -g exclude_aur=false
declare -g exclude_arch=false
declare -g exact_match=false
declare -g check_remote=false
declare -g simple_mode=false
declare -ga search_terms=()

# Data caches - populated once
declare -gA installed_versions
declare -gA official_versions
declare -gA official_repos
declare -gA official_descriptions
declare -gA aur_installed
declare -gA aur_remote_versions  # Cache for AUR remote versions
declare -gA aur_queried_packages  # Track which packages we actually queried AUR for

# Cleanup handler
cleanup() {
    trap - SIGINT SIGTERM EXIT
    pkill -P $$ 2>/dev/null || true
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# Get repo color
get_repo_color() {
    case "$1" in
        core) echo -e "${COL_RED}core${COL_RESET}" ;;
        extra) echo -e "${COL_GREEN}extra${COL_RESET}" ;;
        multilib) echo -e "${COL_CYAN}multilib${COL_RESET}" ;;
        *) echo -e "${COL_MAGENTA}$1${COL_RESET}" ;;
    esac
}

# Fast version comparison
version_differs() {
    [[ "$1" != "$2" ]]
}

# Highlight the changed portion of a new version
# Usage: highlight_version_diff "old_ver" "new_ver"
# Returns the new version with changed parts highlighted in green
highlight_version_diff() {
    local old_ver="$1"
    local new_ver="$2"
    
    # Find common prefix length
    local i=0
    local max_len=${#old_ver}
    [[ ${#new_ver} -lt $max_len ]] && max_len=${#new_ver}
    
    while [[ $i -lt $max_len ]] && [[ "${old_ver:$i:1}" == "${new_ver:$i:1}" ]]; do
        ((i++))
    done
    
    # Back up to last separator (., -, _) for cleaner highlighting
    while [[ $i -gt 0 ]] && [[ ! "${new_ver:$i-1:1}" =~ [.\-_] ]]; do
        ((i--))
    done
    
    # If no common prefix or diverged at start, highlight entire new version
    if [[ $i -eq 0 ]]; then
        echo -e "${COL_GREEN}$new_ver${COL_RESET}"
    else
        # Print common prefix dim, changed part in green
        echo -e "${COL_DIM}${new_ver:0:$i}${COL_RESET}${COL_GREEN}${new_ver:$i}${COL_RESET}"
    fi
}

# Populate all caches in single passes
populate_caches() {
    # Get all installed packages with versions
    while IFS=' ' read -r pkg ver; do
        installed_versions[$pkg]=$ver
    done < <(pacman -Q)
    
    # Get AUR packages
    while IFS=' ' read -r pkg ver; do
        aur_installed[$pkg]=$ver
    done < <(pacman -Qm)
    
    # Get official repo data in one expac call
    if command -v expac &>/dev/null; then
        while IFS=$'\t' read -r name ver repo desc; do
            official_versions[$name]=$ver
            official_repos[$name]=$repo
            official_descriptions[$name]=$desc
        done < <(expac -S '%n\t%v\t%r\t%d' 2>/dev/null)
    fi
}

# Match package against search terms
matches_search() {
    local pkg=$1
    local desc="${2:-}"
    
    if [ ${#search_terms[@]} -eq 0 ]; then
        return 0
    fi
    
    for term in "${search_terms[@]}"; do
        if [ "$exact_match" = true ]; then
            [[ "${pkg,,}" == "${term,,}" ]] && return 0
        else
            if [[ "${pkg,,}" == *"${term,,}"* ]]; then
                return 0
            elif [ "$search_desc" = true ] && [[ "${desc,,}" == *"${term,,}"* ]]; then
                return 0
            fi
        fi
    done
    return 1
}

# Display installed package
display_installed_pkg() {
    local pkg=$1
    
    # Simple mode - just the name
    if [ "$simple_mode" = true ]; then
        echo "$pkg"
        return
    fi
    
    local current_ver="${installed_versions[$pkg]}"
    local remote_ver="${official_versions[$pkg]}"
    local repo="${official_repos[$pkg]}"
    local desc="${official_descriptions[$pkg]}"
    
    echo -e "${COL_GREEN}$CHECK_MARK $pkg${COL_RESET} ${COL_CYAN}(v$current_ver)${COL_RESET}"
    
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    
    echo -ne "${COL_BLUE}└─ Source: Official [$(get_repo_color "$repo")]"
    
    if [ -z "$remote_ver" ]; then
        echo -e " ${COL_YELLOW}$WARNING Unable to check${COL_RESET}"
    elif version_differs "$current_ver" "$remote_ver"; then
        echo -e " ${COL_YELLOW}$UP_ARROW Update: v$current_ver${COL_RESET} → v$(highlight_version_diff "$current_ver" "$remote_ver")"
    else
        echo -e " ${COL_GREEN}$CHECK_MARK Up to date${COL_RESET}"
    fi
    echo
}

# Batch fetch all AUR versions at once
fetch_all_aur_versions() {
    local -a packages=("$@")
    [ ${#packages[@]} -eq 0 ] && return
    
    # Build URL with all packages (excluding VCS packages)
    local url="https://aur.archlinux.org/rpc/v5/info"
    local first=true
    
    for pkg in "${packages[@]}"; do
        # Skip VCS packages as they're always "latest"
        [[ "$pkg" =~ -(git|svn|hg|bzr)$ ]] && continue
        
        # Mark this package as queried (we'll check AUR for it)
        aur_queried_packages[$pkg]=1
        
        if [ "$first" = true ]; then
            url="${url}?arg[]=$(echo -n "$pkg" | jq -sRr @uri)"
            first=false
        else
            url="${url}&arg[]=$(echo -n "$pkg" | jq -sRr @uri)"
        fi
    done
    
    # If all packages were VCS, return
    [ "$first" = true ] && return
    
    # Fetch all versions in one request
    local response=$(curl -s "$url" 2>/dev/null)
    
    if [ -n "$response" ]; then
        while IFS=$'\t' read -r name version; do
            [ -n "$name" ] && aur_remote_versions[$name]=$version
        done < <(echo "$response" | jq -r '.results[] | "\(.Name)\t\(.Version)"' 2>/dev/null)
    fi
}

# Display AUR package (now uses pre-fetched versions)
display_aur_pkg() {
    local pkg=$1
    
    # Simple mode - just the name
    if [ "$simple_mode" = true ]; then
        echo "$pkg"
        return
    fi
    
    local ver="${aur_installed[$pkg]}"
    local desc=""
    
    # Get description if available
    if command -v expac &>/dev/null; then
        desc=$(expac -Q '%d' "$pkg" 2>/dev/null)
    fi
    
    echo -e "${COL_GREEN}$CHECK_MARK $pkg${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    
    # Determine package type:
    # - VCS packages (-git, -svn, etc): "devel"
    # - Queried but not found in AUR: "local" 
    # - Found in AUR: "aur"
    local is_vcs=false
    local is_local=false
    
    if [[ "$pkg" =~ -(git|svn|hg|bzr)$ ]]; then
        is_vcs=true
    elif [[ -n "${aur_queried_packages[$pkg]}" && -z "${aur_remote_versions[$pkg]}" ]]; then
        # We queried AUR for this package but it wasn't in the results
        is_local=true
    fi
    
    # Display based on type
    if [ "$is_local" = true ]; then
        echo -ne "${COL_MAGENTA}└─ Source: Local [${COL_CYAN}local${COL_RESET}${COL_MAGENTA}]"
        echo -e " ${COL_DIM}(not tracked in AUR)${COL_RESET}"
    elif [ "$is_vcs" = true ]; then
        echo -ne "${COL_YELLOW}└─ Source: AUR [${COL_CYAN}devel${COL_RESET}${COL_YELLOW}]"
        echo -e " ${COL_DIM}(VCS package - always latest)${COL_RESET}"
    else
        echo -ne "${COL_YELLOW}└─ Source: AUR [${COL_CYAN}aur${COL_RESET}${COL_YELLOW}]${COL_RESET}"
        
        local remote_ver="${aur_remote_versions[$pkg]}"
        
        if [ -z "$remote_ver" ]; then
            echo -e " ${COL_YELLOW}$WARNING Unable to check${COL_RESET}"
        elif version_differs "$ver" "$remote_ver"; then
            echo -e " ${COL_YELLOW}$UP_ARROW Update: v$ver${COL_RESET} → v$(highlight_version_diff "$ver" "$remote_ver")"
        else
            echo -e " ${COL_GREEN}$CHECK_MARK Up to date${COL_RESET}"
        fi
    fi
    
    echo
}

# Display remote package
display_remote_pkg() {
    local pkg=$1
    
    # Simple mode - just the name
    if [ "$simple_mode" = true ]; then
        echo "$pkg"
        return
    fi
    
    local ver="${official_versions[$pkg]}"
    local repo="${official_repos[$pkg]}"
    local desc="${official_descriptions[$pkg]}"
    
    echo -e "${COL_RED}$X_MARK $pkg${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    echo -e "${COL_BLUE}└─ Available in [$(get_repo_color "$repo")]${COL_RESET}"
    echo
}

# Search AUR via RPC - handles multiple search terms with OR logic
search_aur_remote() {
    local found_any=false
    declare -A seen_packages  # Use associative array for faster lookups
    
    # Debug mode - uncomment to see API calls
    # local debug=true
    local debug=false
    
    # For exact match mode, search each term separately
    if [ "$exact_match" = true ]; then
        for term in "${search_terms[@]}"; do
            local url="https://aur.archlinux.org/rpc/v5/search/$(echo -n "$term" | jq -sRr @uri)?by=name"
            [ "$debug" = true ] && echo "Debug: Searching AUR (exact) for: $term" >&2
            [ "$debug" = true ] && echo "Debug: URL: $url" >&2
            
            local response=$(curl -s "$url" 2>/dev/null)
            [ "$debug" = true ] && echo "Debug: Response length: ${#response}" >&2
            
            if [ -n "$response" ]; then
                while IFS=$'\t' read -r name ver desc; do
                    # For exact match, skip if name doesn't exactly match (case-insensitive)
                    if [[ "${name,,}" != "${term,,}" ]]; then
                        continue
                    fi
                    
                    # Skip if already installed
                    [ -n "${installed_versions[$name]}" ] && continue
                    
                    # Skip if already shown
                    [ -n "${seen_packages[$name]}" ] && continue
                    seen_packages[$name]=1
                    
                    # Simple mode - just the name
                    if [ "$simple_mode" = true ]; then
                        echo "$name"
                    else
                        echo -e "${COL_RED}$X_MARK $name${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
                        [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
                        
                        local pkg_type="aur"
                        [[ "$name" =~ -(git|svn|hg|bzr)$ ]] && pkg_type="devel"
                        echo -e "${COL_YELLOW}└─ Available in AUR [${COL_CYAN}$pkg_type${COL_RESET}]"
                        echo
                    fi
                    
                    found_any=true
                done < <(echo "$response" | jq -r '.results[] | "\(.Name)\t\(.Version)\t\(.Description // "")"' 2>/dev/null)
            fi
        done
    else
        # For non-exact match, search each term and combine results
        for term in "${search_terms[@]}"; do
            local by_field="name"
            [ "$search_desc" = true ] && by_field="name-desc"
            
            local url="https://aur.archlinux.org/rpc/v5/search/$(echo -n "$term" | jq -sRr @uri)?by=$by_field"
            [ "$debug" = true ] && echo "Debug: Searching AUR for: $term (field: $by_field)" >&2
            [ "$debug" = true ] && echo "Debug: URL: $url" >&2
            
            local response=$(curl -s "$url" 2>/dev/null)
            [ "$debug" = true ] && echo "Debug: Response length: ${#response}" >&2
            
            if [ -n "$response" ]; then
                # Check if we got valid JSON with results
                local result_count=$(echo "$response" | jq -r '.resultcount // 0' 2>/dev/null)
                [ "$debug" = true ] && echo "Debug: Result count: $result_count" >&2
                
                if [ "$result_count" != "0" ]; then
                    while IFS=$'\t' read -r name ver desc; do
                        # Skip if empty name
                        [ -z "$name" ] && continue
                        
                        # Skip if already installed
                        [ -n "${installed_versions[$name]}" ] && continue
                        
                        # Skip if we've already shown this package
                        [ -n "${seen_packages[$name]}" ] && continue
                        seen_packages[$name]=1
                        
                        # Simple mode - just the name
                        if [ "$simple_mode" = true ]; then
                            echo "$name"
                        else
                            echo -e "${COL_RED}$X_MARK $name${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
                            [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
                            
                            local pkg_type="aur"
                            [[ "$name" =~ -(git|svn|hg|bzr)$ ]] && pkg_type="devel"
                            echo -e "${COL_YELLOW}└─ Available in AUR [${COL_CYAN}$pkg_type${COL_RESET}]"
                            echo
                        fi
                        
                        found_any=true
                    done < <(echo "$response" | jq -r '.results[]? | "\(.Name)\t\(.Version)\t\(.Description // "")"' 2>/dev/null)
                fi
            fi
        done
    fi
    
    # Don't show "not found" message in simple mode
    if [ "$found_any" = false ] && [ "$simple_mode" = false ]; then
        echo -e "${COL_RED}$X_MARK No packages found in AUR${COL_RESET}\n"
    fi
}

# Show help
show_help() {
    cat <<EOF
pacheck - Fast package checker for Arch Linux

Usage: pacheck [options] <search-terms...>

Options:
    -h, --help          Show this help message
    -r, --remote        Include remote packages in search
    -d, --desc          Search package descriptions
    -e, --exact         Match package names exactly
    -s, --simple        Simple output (package names only, one per line)
    --exclude-aur       Exclude AUR packages
    --exclude-arch      Exclude official packages

Examples:
    pacheck python              # Search installed for "python"
    pacheck -r node             # Include remote packages
    pacheck -d compression      # Search descriptions
    pacheck -e wine             # Exact match only
    pacheck -s lib              # Simple output (names only)
    pacheck -rs python          # Remote search, simple output
EOF
}

# Main function
main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -r|--remote)
                check_remote=true
                shift
                ;;
            -d|--desc)
                search_desc=true
                shift
                ;;
            -e|--exact)
                exact_match=true
                search_desc=false
                shift
                ;;
            -s|--simple)
                simple_mode=true
                shift
                ;;
            --exclude-aur)
                exclude_aur=true
                shift
                ;;
            --exclude-arch)
                exclude_arch=true
                shift
                ;;
            -*)
                # Handle combined flags like -rd, -rs, etc.
                if [[ "$1" =~ r ]]; then check_remote=true; fi
                if [[ "$1" =~ d ]]; then search_desc=true; fi
                if [[ "$1" =~ e ]]; then exact_match=true; search_desc=false; fi
                if [[ "$1" =~ s ]]; then simple_mode=true; fi
                shift
                ;;
            *)
                search_terms+=("$1")
                shift
                ;;
        esac
    done
    
    # Show help if no search terms
    if [ ${#search_terms[@]} -eq 0 ]; then
        show_help
        exit 1
    fi
    
    # Don't show header in simple mode
    if [ "$simple_mode" = false ]; then
        echo -e "${COL_BOLD}Searching for: ${search_terms[*]}${COL_RESET}\n"
    fi
    
    # Populate all caches upfront
    populate_caches
    
    # Process installed official packages
    if [ "$exclude_arch" = false ]; then
        local found_official=false
        
        for pkg in "${!installed_versions[@]}"; do
            # Skip AUR packages
            [ -n "${aur_installed[$pkg]}" ] && continue
            
            # Check if matches search
            local desc="${official_descriptions[$pkg]}"
            matches_search "$pkg" "$desc" || continue
            
            if [ "$found_official" = false ]; then
                if [ "$simple_mode" = false ]; then
                    echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                    echo -e "${COL_BOLD}${COL_CYAN}Official Repositories Installed:${COL_RESET}"
                    echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                fi
                found_official=true
            fi
            
            display_installed_pkg "$pkg"
        done
        
        if [ "$found_official" = false ] && [ "$exclude_aur" = true ] && [ "$simple_mode" = false ]; then
            echo -e "${COL_RED}$X_MARK No installed packages found${COL_RESET}\n"
        fi
    fi
    
    # Process installed AUR packages
    if [ "$exclude_aur" = false ]; then
        local found_aur=false
        declare -a matching_aur_packages=()
        
        # First, collect all matching AUR packages
        for pkg in "${!aur_installed[@]}"; do
            # Get description for matching
            local desc=""
            if [ "$search_desc" = true ] && command -v expac &>/dev/null; then
                desc=$(expac -Q '%d' "$pkg" 2>/dev/null)
            fi
            
            matches_search "$pkg" "$desc" || continue
            matching_aur_packages+=("$pkg")
        done
        
        # Batch fetch all AUR versions at once
        if [ ${#matching_aur_packages[@]} -gt 0 ]; then
            fetch_all_aur_versions "${matching_aur_packages[@]}"
            
            if [ "$simple_mode" = false ]; then
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
                echo -e "${COL_BOLD}${COL_YELLOW}AUR/Local Installed:${COL_RESET}"
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
            fi
            
            # Now display all matching packages
            for pkg in "${matching_aur_packages[@]}"; do
                display_aur_pkg "$pkg"
            done
        fi
    fi
    
    # Process remote packages if requested
    if [ "$check_remote" = true ]; then
        # Official remote packages
        if [ "$exclude_arch" = false ]; then
            local found_remote=false
            
            for pkg in "${!official_versions[@]}"; do
                # Skip installed
                [ -n "${installed_versions[$pkg]}" ] && continue
                
                # Check match
                matches_search "$pkg" "${official_descriptions[$pkg]}" || continue
                
                if [ "$found_remote" = false ]; then
                    if [ "$simple_mode" = false ]; then
                        echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                        echo -e "${COL_BOLD}${COL_BLUE}Official Repositories Available:${COL_RESET}"
                        echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                    fi
                    found_remote=true
                fi
                
                display_remote_pkg "$pkg"
            done
            
            if [ "$found_remote" = false ] && [ "$exclude_aur" = true ] && [ "$simple_mode" = false ]; then
                echo -e "${COL_RED}$X_MARK No remote packages found${COL_RESET}\n"
            fi
        fi
        
        # AUR remote packages
        if [ "$exclude_aur" = false ]; then
            if [ "$simple_mode" = false ]; then
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
                echo -e "${COL_BOLD}${COL_YELLOW}AUR Available:${COL_RESET}"
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
            fi
            
            search_aur_remote
        fi
    fi
}

main "$@"
