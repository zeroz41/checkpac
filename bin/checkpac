#!/bin/bash

# Optimized pacheck - Fast parallel package checker for Arch Linux
# Made by zeroz/tj - Optimized version

# Dependencies: expac, curl, jq
# Optional: pacman-contrib (for paccache)

# Set safer bash options
set -o pipefail

# Terminal colors
readonly COL_RESET="\e[0m"
readonly COL_BOLD="\e[1m"
readonly COL_RED="\e[31m"
readonly COL_GREEN="\e[32m"
readonly COL_YELLOW="\e[33m"
readonly COL_BLUE="\e[34m"
readonly COL_CYAN="\e[36m"
readonly COL_MAGENTA="\e[35m"
readonly COL_DIM="\e[2m"
readonly COL_HIGHLIGHT="\e[94m"

# Unicode symbols
readonly CHECK_MARK=$'\u2714'
readonly X_MARK=$'\u2718'
readonly UP_ARROW=$'\u2191'
readonly WARNING=$'\u25B2'
readonly DIVIDER="────────────────────────────────────"

# Global settings
declare -g search_desc=false
declare -g exclude_aur=false
declare -g exclude_arch=false
declare -g exact_match=false
declare -g check_remote=false
declare -ga search_terms=()

# Data caches - populated once
declare -gA installed_versions
declare -gA official_versions
declare -gA official_repos
declare -gA official_descriptions
declare -gA aur_installed

# Cleanup handler
cleanup() {
    trap - SIGINT SIGTERM EXIT
    pkill -P $$ 2>/dev/null || true
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# Get repo color
get_repo_color() {
    case "$1" in
        core) echo -e "${COL_RED}core${COL_RESET}" ;;
        extra) echo -e "${COL_GREEN}extra${COL_RESET}" ;;
        multilib) echo -e "${COL_CYAN}multilib${COL_RESET}" ;;
        *) echo -e "${COL_MAGENTA}$1${COL_RESET}" ;;
    esac
}

# Fast version comparison
version_differs() {
    [[ "$1" != "$2" ]]
}

# Populate all caches in single passes
populate_caches() {
    # Get all installed packages with versions
    while IFS=' ' read -r pkg ver; do
        installed_versions[$pkg]=$ver
    done < <(pacman -Q)
    
    # Get AUR packages
    while IFS=' ' read -r pkg ver; do
        aur_installed[$pkg]=$ver
    done < <(pacman -Qm)
    
    # Get official repo data in one expac call
    if command -v expac &>/dev/null; then
        while IFS=$'\t' read -r name ver repo desc; do
            official_versions[$name]=$ver
            official_repos[$name]=$repo
            official_descriptions[$name]=$desc
        done < <(expac -S '%n\t%v\t%r\t%d' 2>/dev/null)
    fi
}

# Match package against search terms
matches_search() {
    local pkg=$1
    local desc="${2:-}"
    
    if [ ${#search_terms[@]} -eq 0 ]; then
        return 0
    fi
    
    for term in "${search_terms[@]}"; do
        if [ "$exact_match" = true ]; then
            [[ "${pkg,,}" == "${term,,}" ]] && return 0
        else
            if [[ "${pkg,,}" == *"${term,,}"* ]]; then
                return 0
            elif [ "$search_desc" = true ] && [[ "${desc,,}" == *"${term,,}"* ]]; then
                return 0
            fi
        fi
    done
    return 1
}

# Display installed package
display_installed_pkg() {
    local pkg=$1
    local current_ver="${installed_versions[$pkg]}"
    local remote_ver="${official_versions[$pkg]}"
    local repo="${official_repos[$pkg]}"
    local desc="${official_descriptions[$pkg]}"
    
    echo -e "${COL_GREEN}$CHECK_MARK $pkg${COL_RESET} ${COL_CYAN}(v$current_ver)${COL_RESET}"
    
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    
    echo -ne "${COL_BLUE}└─ Source: Official [$(get_repo_color "$repo")]"
    
    if [ -z "$remote_ver" ]; then
        echo -e " ${COL_YELLOW}$WARNING Unable to check${COL_RESET}"
    elif version_differs "$current_ver" "$remote_ver"; then
        echo -e " ${COL_YELLOW}$UP_ARROW Update: v$current_ver → v$remote_ver${COL_RESET}"
    else
        echo -e " ${COL_GREEN}$CHECK_MARK Up to date${COL_RESET}"
    fi
    echo
}

fetch_aur_version() {
    local pkg=$1
    local url="https://aur.archlinux.org/rpc/v5/info?arg[]=$(echo -n "$pkg" | jq -sRr @uri)"
    local response=$(curl -s "$url" 2>/dev/null)
    
    if [ -n "$response" ]; then
        echo "$response" | jq -r '.results[0].Version // ""' 2>/dev/null
    fi
}

# Replace the existing display_aur_pkg function with this updated version
display_aur_pkg() {
    local pkg=$1
    local ver="${aur_installed[$pkg]}"
    local desc=""
    
    # Get description if available
    if command -v expac &>/dev/null; then
        desc=$(expac -Q '%d' "$pkg" 2>/dev/null)
    fi
    
    echo -e "${COL_GREEN}$CHECK_MARK $pkg${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    
    local pkg_type="aur"
    [[ "$pkg" =~ -(git|svn|hg|bzr)$ ]] && pkg_type="devel"
    
    echo -ne "${COL_YELLOW}└─ Source: AUR [${COL_CYAN}$pkg_type${COL_RESET}]"
    
    # Check for updates (skip for VCS packages as they're always "latest")
    if [[ ! "$pkg" =~ -(git|svn|hg|bzr)$ ]]; then
        local remote_ver=$(fetch_aur_version "$pkg")
        
        if [ -z "$remote_ver" ]; then
            echo -e " ${COL_YELLOW}$WARNING Unable to check${COL_RESET}"
        elif version_differs "$ver" "$remote_ver"; then
            echo -e " ${COL_YELLOW}$UP_ARROW Update: v$ver → v$remote_ver${COL_RESET}"
        else
            echo -e " ${COL_GREEN}$CHECK_MARK Up to date${COL_RESET}"
        fi
    else
        echo -e " ${COL_DIM}(VCS package - always latest)${COL_RESET}"
    fi
    
    echo
}
#

# Display remote package
display_remote_pkg() {
    local pkg=$1
    local ver="${official_versions[$pkg]}"
    local repo="${official_repos[$pkg]}"
    local desc="${official_descriptions[$pkg]}"
    
    echo -e "${COL_RED}$X_MARK $pkg${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
    echo -e "${COL_BLUE}└─ Available in [$(get_repo_color "$repo")]${COL_RESET}"
    echo
}

# Search AUR via RPC (much faster)
# Search AUR via RPC - handles multiple search terms with OR logic
#!/bin/bash

# Search AUR via RPC - handles multiple search terms with OR logic
search_aur_remote() {
    local found_any=false
    declare -A seen_packages  # Use associative array for faster lookups
    
    # Debug mode - uncomment to see API calls
    # local debug=true
    local debug=false
    
    # For exact match mode, search each term separately
    if [ "$exact_match" = true ]; then
        for term in "${search_terms[@]}"; do
            local url="https://aur.archlinux.org/rpc/v5/search/$(echo -n "$term" | jq -sRr @uri)?by=name"
            [ "$debug" = true ] && echo "Debug: Searching AUR (exact) for: $term" >&2
            [ "$debug" = true ] && echo "Debug: URL: $url" >&2
            
            local response=$(curl -s "$url" 2>/dev/null)
            [ "$debug" = true ] && echo "Debug: Response length: ${#response}" >&2
            
            if [ -n "$response" ]; then
                while IFS=$'\t' read -r name ver desc; do
                    # For exact match, skip if name doesn't exactly match (case-insensitive)
                    if [[ "${name,,}" != "${term,,}" ]]; then
                        continue
                    fi
                    
                    # Skip if already installed
                    [ -n "${installed_versions[$name]}" ] && continue
                    
                    # Skip if already shown
                    [ -n "${seen_packages[$name]}" ] && continue
                    seen_packages[$name]=1
                    
                    echo -e "${COL_RED}$X_MARK $name${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
                    [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
                    
                    local pkg_type="aur"
                    [[ "$name" =~ -(git|svn|hg|bzr)$ ]] && pkg_type="devel"
                    echo -e "${COL_YELLOW}└─ Available in AUR [${COL_CYAN}$pkg_type${COL_RESET}]"
                    echo
                    
                    found_any=true
                done < <(echo "$response" | jq -r '.results[] | "\(.Name)\t\(.Version)\t\(.Description // "")"' 2>/dev/null)
            fi
        done
    else
        # For non-exact match, search each term and combine results
        for term in "${search_terms[@]}"; do
            local by_field="name"
            [ "$search_desc" = true ] && by_field="name-desc"
            
            local url="https://aur.archlinux.org/rpc/v5/search/$(echo -n "$term" | jq -sRr @uri)?by=$by_field"
            [ "$debug" = true ] && echo "Debug: Searching AUR for: $term (field: $by_field)" >&2
            [ "$debug" = true ] && echo "Debug: URL: $url" >&2
            
            local response=$(curl -s "$url" 2>/dev/null)
            [ "$debug" = true ] && echo "Debug: Response length: ${#response}" >&2
            
            if [ -n "$response" ]; then
                # Check if we got valid JSON with results
                local result_count=$(echo "$response" | jq -r '.resultcount // 0' 2>/dev/null)
                [ "$debug" = true ] && echo "Debug: Result count: $result_count" >&2
                
                if [ "$result_count" != "0" ]; then
                    while IFS=$'\t' read -r name ver desc; do
                        # Skip if empty name
                        [ -z "$name" ] && continue
                        
                        # Skip if already installed
                        [ -n "${installed_versions[$name]}" ] && continue
                        
                        # Skip if we've already shown this package
                        [ -n "${seen_packages[$name]}" ] && continue
                        seen_packages[$name]=1
                        
                        echo -e "${COL_RED}$X_MARK $name${COL_RESET} ${COL_CYAN}(v$ver)${COL_RESET}"
                        [ -n "$desc" ] && echo -e "${COL_DIM}$desc${COL_RESET}"
                        
                        local pkg_type="aur"
                        [[ "$name" =~ -(git|svn|hg|bzr)$ ]] && pkg_type="devel"
                        echo -e "${COL_YELLOW}└─ Available in AUR [${COL_CYAN}$pkg_type${COL_RESET}]"
                        echo
                        
                        found_any=true
                    done < <(echo "$response" | jq -r '.results[]? | "\(.Name)\t\(.Version)\t\(.Description // "")"' 2>/dev/null)
                fi
            fi
        done
    fi
    
    [ "$found_any" = false ] && echo -e "${COL_RED}$X_MARK No packages found in AUR${COL_RESET}\n"
}

# Show help
show_help() {
    cat <<EOF
pacheck - Fast package checker for Arch Linux

Usage: pacheck [options] <search-terms...>

Options:
    -h, --help          Show this help message
    -r, --remote        Include remote packages in search
    -d, --desc          Search package descriptions
    -e, --exact         Match package names exactly
    --exclude-aur       Exclude AUR packages
    --exclude-arch      Exclude official packages

Examples:
    pacheck python              # Search installed for "python"
    pacheck -r node             # Include remote packages
    pacheck -d compression      # Search descriptions
    pacheck -e wine             # Exact match only
EOF
}

# Main function
main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -r|--remote)
                check_remote=true
                shift
                ;;
            -d|--desc)
                search_desc=true
                shift
                ;;
            -e|--exact)
                exact_match=true
                search_desc=false
                shift
                ;;
            --exclude-aur)
                exclude_aur=true
                shift
                ;;
            --exclude-arch)
                exclude_arch=true
                shift
                ;;
            -*)
                # Handle combined flags like -rd
                if [[ "$1" =~ r ]]; then check_remote=true; fi
                if [[ "$1" =~ d ]]; then search_desc=true; fi
                if [[ "$1" =~ e ]]; then exact_match=true; search_desc=false; fi
                shift
                ;;
            *)
                search_terms+=("$1")
                shift
                ;;
        esac
    done
    
    # Show help if no search terms
    if [ ${#search_terms[@]} -eq 0 ]; then
        show_help
        exit 1
    fi
    
    echo -e "${COL_BOLD}Searching for: ${search_terms[*]}${COL_RESET}\n"
    
    # Populate all caches upfront
    populate_caches
    
    # Process installed official packages
    if [ "$exclude_arch" = false ]; then
        local found_official=false
        
        for pkg in "${!installed_versions[@]}"; do
            # Skip AUR packages
            [ -n "${aur_installed[$pkg]}" ] && continue
            
            # Check if matches search
            local desc="${official_descriptions[$pkg]}"
            matches_search "$pkg" "$desc" || continue
            
            if [ "$found_official" = false ]; then
                echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                echo -e "${COL_BOLD}${COL_CYAN}Official Repositories Installed:${COL_RESET}"
                echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                found_official=true
            fi
            
            display_installed_pkg "$pkg"
        done
        
        [ "$found_official" = false ] && [ "$exclude_aur" = true ] && \
            echo -e "${COL_RED}$X_MARK No installed packages found${COL_RESET}\n"
    fi
    
    # Process installed AUR packages
    if [ "$exclude_aur" = false ]; then
        local found_aur=false
        
        for pkg in "${!aur_installed[@]}"; do
            # Get description for matching
            local desc=""
            if [ "$search_desc" = true ] && command -v expac &>/dev/null; then
                desc=$(expac -Q '%d' "$pkg" 2>/dev/null)
            fi
            
            matches_search "$pkg" "$desc" || continue
            
            if [ "$found_aur" = false ]; then
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
                echo -e "${COL_BOLD}${COL_YELLOW}AUR Installed:${COL_RESET}"
                echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
                found_aur=true
            fi
            
            display_aur_pkg "$pkg"
        done
    fi
    
    # Process remote packages if requested
    if [ "$check_remote" = true ]; then
        # Official remote packages
        if [ "$exclude_arch" = false ]; then
            local found_remote=false
            
            for pkg in "${!official_versions[@]}"; do
                # Skip installed
                [ -n "${installed_versions[$pkg]}" ] && continue
                
                # Check match
                matches_search "$pkg" "${official_descriptions[$pkg]}" || continue
                
                if [ "$found_remote" = false ]; then
                    echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                    echo -e "${COL_BOLD}${COL_BLUE}Official Repositories Available:${COL_RESET}"
                    echo -e "${COL_BLUE}$DIVIDER${COL_RESET}"
                    found_remote=true
                fi
                
                display_remote_pkg "$pkg"
            done
            
            [ "$found_remote" = false ] && [ "$exclude_aur" = true ] && \
                echo -e "${COL_RED}$X_MARK No remote packages found${COL_RESET}\n"
        fi
        
        # AUR remote packages
        if [ "$exclude_aur" = false ]; then
            echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
            echo -e "${COL_BOLD}${COL_YELLOW}AUR Available:${COL_RESET}"
            echo -e "${COL_YELLOW}$DIVIDER${COL_RESET}"
            
            search_aur_remote
        fi
    fi
}

main "$@"